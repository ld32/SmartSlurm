#!/bin/sh

#set -x

submttingLog=.smartSlurm.log

if [[ $1 == "-h" ||  $i == "--help" ]]; then
    echo "checkRun: This script can guild user to debug smartSlurm runs." 
    exit 1; 
fi
if [ -f ~/.smartSlurm/config/config.txt ]; then
    source ~/.smartSlurm/config/config.txt
else
    source $(dirname $0)/../config/config.txt || { echoerr Config list file not found: config.txt; exit 1; }
fi

#export smartSlurmLogDir=smartSlurmLog #log

[ -f .smartSlurm.log ] || { echo .smartSlurm.log is not found. Please go to the folder from which you ran runAsPipeline; exit; }

logFolders=`ls -d -t $smartSlurmLogDir $smartSlurmLogDir.20*  $submttingLog* $smartSlurmJobRecordDir/jobRecord.txt 2>/dev/null`

[ -z "$logFolders" ] && echo Log folder name does not exist: $smartSlurmLogDir. Maybe you are not in the project folder? && usage 

IFS=$'\n'
activeJobs=`squeue -u $USER -t PD,R --noheader -o "%.18i-%t"`

RED='\033[0;31m'
NC='\033[0m' # No Color
GREEN='\033[0;32m'

while true; do
    echo Availale logFolders or file:
    count=1
    for i in $logFolders; do
    
         # no job is submitted, ignore it
        if [ -f "$i" ]; then 
            nJobs=$(grep "Got output from ssbatch: Submitted batch job" $i | wc -l)
            if [ $nJobs -gt 0 ] || [ ! -z "$all" ]; then 
                
                echo -en "${GREEN}$(printf "%-2s\n" $count)${NC}"
                #echo Submitted $(grep "Got output from ssbatch: Submitted batch job" $i | wc -l) jobs 
                printf "%-50s %-15s\n" " file:   $i" "$nJobs jobs submitted"
                count=$((count + 1))
            fi 
            
        else 
            if [ -f $i/allJobs.txt ]; then 
                nJobs=$(($(wc -l < $i/allJobs.txt) -1))
                if [ $nJobs -gt 0 ] || [ ! -z "$all" ]; then 
                    echo -en "${RED}$(printf "%-2s\n" $count)${NC}"
                    
                    printf "%-50s %-15s\n" " folder: $i" "$nJobs jobs submitted"

                    count=$((count + 1))
                fi 
            fi 
        fi  
        [ $nJobs -eq 0 ] && hidden=y    
    done
    if [ $count -eq 2 ] && [ -z "$x" ]; then
        
        echo Only one logFolder. No need to select.
        x=1 
        #firstRound=y
        #x=1
    else
        if [ -z "$hidden" ]; then 
            echo -e "Please select the logFolder you want to check or type ${RED}q${NC} to quit:"
        else 
            echo -e "Please select the logFolder you want to check or type ${RED}q${NC} to quit, and ${GREEN}a${NC} to show/hide no job logs:"
        fi 
        read -p "" x </dev/tty
        [[ "$x" == q ]] && break
        if [[ "$x" == a ]]; then 
            [[ "$all" = y ]] && all="" || all=y 
            continue
        fi     
        [[ "$x" == h ]] && all="" && continue

        [[ "$x" =~ ^[0-9]+$ && "$x" -lt $count && "$x" -ne 0 ]] || { echo -e "${RED}Out of range. Should be between > 0 and < $count"; continue; }
    fi
    
    logFolder=`echo $logFolders | cut -d' ' -f$x`

    [ -f "$logFolder" ] && less $logFolder && continue

    lines=`tail -n +2 $logFolder/allJobs.txt | awk 'NF>2{print $1, $2, $3}'`

    current=0; succ=0; fail=0; running=0; pending=0; requeue=0; unknown=0
    toShow="Summery for jobs in allJobs.txt:"
    for line in $lines; do
        if [ ! -z "${line/ /}" ]; then
            id=${line%% *}; name=${line##* }

            if [ -f $logFolder/$name.success ]; then
                toShow="$toShow\n${NC}Done $line"
                succ=$((succ + 1))
            elif [ -f $logFolder/$name.failed ]; then
                toShow="$toShow\n${RED}Fail${NC} $line"
                fail=$((fail + 1))
            elif [[ "$activeJobs" == *$id-R* ]]; then # && [[ "$id" != "$SLURM_JOBID" ]]; then
                toShow="$toShow\n${GREEN}Runn${NC} $line"
                running=$((running + 1))
            elif [[ "$activeJobs" == *$id-P* ]]; then # && [[ "$id" != "$SLURM_JOBID" ]]; then
                toShow="$toShow\n${RED}Pend${NC} $line"
                pending=$((pending + 1))
            elif [ -f $logFolder/$name.failed.requeued.1.time ]; then 
                toShow="$toShow\n${RED}Requ${NC} $line"
                requeue=$((requeue + 1))    
            else
                toShow="$toShow\n${RED}Unkn${NC} $line"
                unknown=$((unknown + 1))
            fi
        fi
    done

    while true; do
        echo Available logs:
        count=1
        IFS=$'\n'
        #set -x 
        for i in `echo -e "$toShow" | tail -n +2`; do
            echo -e "$GREEN$count ${i#*\/}"
            count=$((count + 1))
        done
      
        if [ $count -eq 2 ] && [ -z "$xx" ]; then
            echo Only one failed step. No need to select.
            xx=1
        else
            [ ! -z "$xx" ] && echo -en "Type ${RED}s${NC} to see the slurm script for last .out log.
Or ${RED}r${NC} to run the job command. 
Or ${RED}l${NC} to list all log file related to this job. Or "
            echo -e "Select a failed step to check the .out log or type ${RED}q${NC} to quit:"
            read -p "" xx </dev/tty;
        
            [[ "$xx" == s ]] && less $logFolder/$failedJob.sh && continue

            if [[ "$xx" == r ]]; then 
                #set -x 
                echo -e "${RED}Command to re-run the job interactively:"
                echo 
                jobStep=${failedJob##*/}
                jobStep=${jobStep%%.*}
                file=`ls -lrt $logFolder/slurm*.run.sh`
                txt=`cat ${file##* }`
                txt=${txt%%\#@$jobStep*}
                echo -e "$txt" | grep "module load \|export PATH" 
                 
                txt=`grep pipefail $logFolder/$failedJob.sh`
                txt=${txt#*-c \'}
                txt=${txt%\' && touch*}
                echo $txt | less 
                #set +x 
                continue
            fi 
            [[ "$xx" == q ]] && break
            
            [[ "$xx" == l ]] && ls -l $logFolder/$failedJob* | less 
            [[ "$xx" =~ ^[0-9]+$ && "$xx" -lt $count && "$xx" -ne 0 ]] || { echo -e "${RED}Out of range. Should be > 0 and < $count";  continue; }
        fi
        
        failedJob=`echo -e "$toShow" | tail -n +2 | head -n $xx | tail -n1 | awk '{print $NF}'`
        
        less $logFolder/$failedJob.out

        #set +x 
    done
done
