#!/bin/sh

## notes: to estimate resource, need at least three jobs if no input size is given, and 5 jobs if there is input size given

## features for regular sbatch (when calling without -L)
# Auto adjust partition according to run-time request if they does not match up
# Auto check if slurm script exists
# Auto create output and erro folders if not exist
# Auto adjust memory and run time based on earlier mem time usage 
# Support re-run checking (using output as checkpoint)
# Auto adjust memory and run time based on earlier mem time usage
# Auto requeue job with double time when out of time
# Auto requeue job with double memory when out of memory
# Keep good log and send informative email
# allow user level config file in ~/.smartSlurm/config.txt

# Limitations: 
# does not take logs in logDir, does not take care of re-run because there is not unique flag for the job, does not take care of downstream jobs

# todo:

## features with smartPipeline
# Auto adjust partition according to run-time request if they does not match up
# Auto check if slurm script exists
# Auto create output and erro folders if not exist
# Auto adjust partition according to run-time request if they does not match up
# Auto adjust memory and run time based on earlier mem time usage
# Support re-run from breaking-point
# Auto requeue job with double time when out of time
# Auto requeue job with double memory when out of memory
# Keep good log and send informative email

# todo:

# the logic, if has input, check if stat file exist, if not make one. Then estimate mem/time  

#set -e
#set -x 

# extraMin=5 # 5min. extra minutes than the estimated time
# extraMem=5  # 5M. extra memory than the estinated memory

usage() { echo -e "Short Usage: \n${0##*/} [-L logDir (for smartPipline)]  [-S software] [-R reference] [-F uniqueJobFlag (for smartPieline)s] [-I inputList] [-D Dependencies (for smartPipeline)] [sbatch options] [run]\nDetail Detail Usage:\n${0##*/} [-L logDir, optional. Such as: ./], [-S software, optional. Such as: bowtie2-4core. If empty, use script name as software name] [-R reference, optional. Such as: hg19] [-F uniqueJobFlag, optional. Such as 1.bowtie.s1.fa] [-I inputFileOrFolderList, optional. Such as: read1.fq,read2.fq] [ -D dependent jobs] <regular sbatch options, optional. Such as: job.sh or -p short -c 1 -t 2:0:0 --mem 2G --wrap \"my_application para1 para2\"> [run, optional: run will submit job, empty will do a dry run without submitting a job.]"; exit 1; }

[ -z "$1" ] && usage

[[ "-h" == "$1" ]] && usage        

[[ "--help" == "$1" ]] && usage

if [ -f ~/.smartSlurm/config.txt ]; then 
    source ~/.smartSlurm/config.txt
else     
    source $(dirname $0)/../config/config.txt || { echo Config list file not found: config.txt; exit 1; }
fi

mkdir -p $jobRecordDir/stats

echo Running: $0 $@ 1>&2

cmd="ssbatch"
whitespace="[[:space:]]"
for i in "$@"; do
    if [[ $i =~ $whitespace ]]; then
        i="\"$i\""
    fi
    cmd="$cmd  $i"
done
echo $cmd

#comment="${SSBATCH_I}${SSBATCH_R}${SSBATCH_S}${SSBATCH_D}"

testRun=${@: -1} 

echo 
array=( "$@" )

# get the 6 parameters for ssbatch
for (( i=0; i<$(($#)); i++ )); do
    [ -z "${array[$i]}" ] && continue
#  	echo $i " / " $(($#)) " : " ${array[$i]}
  	case "${array[$i]}" in
        --comment=*     )   comment="${array[$i]}" && array[$i]="" && arr=(${comment/--comment=/}) && for c in "${arr[@]}"; do eval $c; done;;
  	    "-L"            )   logDir="${array[$i+1]}" && array[$i]="" && array[$i+1]="";; 
  		--LogDir=*      )   logDir="${array[$i]}" && logDir=${logDir/--LogDir=/} && array[$i]="";;
  		"-S" 			)   software="${array[$i+1]}" && array[$i]="" && array[$i+1]="";;
  		--Software=* 	)   software="${array[$i]}" && software="${software/--Software=/}" && array[$i]="";;
  		"-R" 			)   ref="${array[$i+1]}" && array[$i]="" && array[$i+1]="";;
  		--Ref=* 		)   ref="${array[$i]}" && ref="${ref/--Ref=/}" && array[$i]="";;
  		"-F" 			)   flag="${array[$i+1]}" && array[$i]="" && array[$i+1]="";;
  		--Flag=* 	    )   flag="${array[$i]}" && flag="${flag/--Flag=/}" && array[$i]="";;
        "-I" 			)   inputs="${array[$i+1]}" && array[$i]="" && array[$i+1]="";;
  		--Inputs=* 	    )   inputs="${array[$i]}" && inputs="${inputs/--Inputs=/}" && array[$i]="";;
        "-D"            )   deps="${array[$i+1]}" && array[$i]="" && array[$i+1]="";;
        "--Dependency=" )   deps="${array[$i]}" && deps="${deps/--Dependency=/}" && array[$i]="";;
        *               )   sbatchLocation=$i && break
    esac
done 

[ -z "$logDir" ] && set -- "$@" run && testRun=run

echo options before sbatch options: slurmAcc: $slurmAcc logDir: $logDir software: $software ref: $ref jobFlag: $flag inputs: $inputs deps: $deps

#exit

depsO=$deps 

echo Parsing sbatch command... 
for (( i=$sbatchLocation; i<`[[ "$testRun" == "run" ]] && echo $(($# -1))  || echo $(($#))`; i++ )); do
    [ -z "${array[$i]}" ] && continue
#  	echo $i " / " $(($#)) " : " ${array[$i]}    
  	case "${array[$i]}" in
  	    "-p"            )   partition="${array[$i+1]}" && array[$i]="" && array[$i+1]="";; # will set partition later
  		--partition=*   )   partition="${array[$i]}" && partition=${partition/--partition=/} && array[$i]="";;
  		--mem-per-cpu=* ) 	mem1="${array[$i]}" && mem1="${mem1/--mem-per-cpu=/}";;
  		"-c" 	 		) 	core="${array[$i+1]}";;
  		--cpus-per-task=*)  core="${array[$i]}" && core="${core/--cpus-per-task=/}";;
  		"-n" 	 		) 	task="${array[$i+1]}";;
  		--ntasks=*      )   task="${array[$i]}" && task="${task/--ntasks=/}";;
  		"-N" 	 		) 	node="${array[$i+1]}" && array[$i]="" && array[$i+1]="";;
  		--nodes=*       )   node="${array[$i]}" && node="${node/--nodes=/}" && array[$i]="";;
  		"--mem"  		) 	mem="${array[$i+1]}"&& array[$i]="" && array[$i+1]="";; # will set memory later
  		--mem=* 		)  	[ -z "$mem" ] && mem="${array[$i]}" && mem=${mem/--mem=/} && array[$i]="";;
  		"-t" 			)   time="${array[$i+1]}" && array[$i]="" && array[$i+1]="";;
  		--time=* 		)   time="${array[$i]}" && time="${time/--time=/}" && array[$i]="";;
  		"-o" 			)   out="${array[$i+1]}" && array[$i]="" && array[$i+1]="";;
  		--output=* 		)   out="${array[$i]}" && out="${out/--oupput=/}" && array[$i]="";;
  		"-e" 			)   err="${array[$i+1]}" && array[$i]="" && array[$i+1]="";;
  		--error=* 		)   err="${array[$i]}" && err="${err/--error=/}" && array[$i]="";;
        "-A"            )   [ -z "$slurmAcc" ] && slurmAcc="-A ${array[$i+1]}" && array[$i]="" && array[$i+1]="";;
        "-d" 			)   dep="${array[$i+1]}";;
  		--dependency=* 	)   dep="${array[$i]}" && dep="${dep/--dependency=/}";;
  		
    esac
 
    [ -z "$wrapCMD" ] && [[ ${array[$i]} == "--wrap" ]] && echo Found --wrap ${array[$i+1]} && wrapCMD="${array[$i+1]}" && array[$i]="" && array[$i+1]="" 
  	[ -z "$wrapCMD" ] && [[ ${array[$i]} ==	--wrap=* ]] && echo Found --wrap= && wrapCMD="${array[$i]}" && wrapCMD="${wrapCMD/--wrap=}" && array[$i]="" || CMDWithoutWrap="$CMDWithoutWrap ${array[$i]}"
    [ -z "$slurmScript$wrapCMD" ] && [ -f "${array[$i]}" ] && echo Found slurmScript ${array[$i]} && slurmScript="${array[$i]}" && array[$i]=""
    [ -z "$slurmScript" ] && CMDWithoutSlurmCMD="$CMDWithoutSlurmCMD ${array[$i]}" || slurmScriptParas="$slurmScriptParas ${array[$i]}"
done 

echo 
echo Parsing result from sbatch commandline: 
echo sbatch options: partition: $partition time: $time mem: $mem mem-per-cpu: $mem1 task: $task core: $core node: $node out: $out err: $err dep: $dep

if [ -z "$slurmScript" ]; then
    echo wrapCMD: $wrapCMD 
    echo additional sbatch parameter: $CMDWithoutWrap 
else 
    echo additional sbatch parameter: $CMDWithoutSlurmCMD
    echo slurmScript: $slurmScript 
    echo slurmScriptParas: $slurmScriptParas
fi
echo test or run: $testRun

if [ ! -z "$slurmScript" ]; then 
  echo Validating slurmScript: 
  firstRow=`head -n 1 $slurmScript`
  echo FirstRow of the script: $firstRow
  [[ "$firstRow" =~ ^#\!/bin/bash ]] || [[ "$firstRow" =~ ^#\!/usr/bin/bash ]] || [[ "$firstRow" =~ ^#\!/bin/sh ]] || [[ "$firstRow" =~ ^#\!/usr/bin/sh ]]|| { echo "Error: first row of the slurm script ($slurmScript) does not start with #!/bin/bash, #!/usr/bin/bash, #!/bin/sh, #!/usr/bin/sh";  exit 1;}
fi

[ -z "$wrapCMD" ] && [ -z "$slurmScript" ] && echo Error: Did not find --wrap, did not find slurmScript either. && exit 1 

if [[ ! -z "$slurmScript" ]]; then 
    echo 
    echo Parsing slurm script ... 
    while IFS=$'\n' read line; do
        echo Got line: $line
        arr=($line)
        if [[ ${arr[0]} == "#SBATCH" ]]; then 
            case "${arr[1]}" in 
                --comment=*    )   echo found --comment && comment="${arr[1]}" && ar=(${comment/--comment=/}) && for c in "${ar[@]}"; do v=${c%=*}; [ -z "${!v}" ] && eval $c; done;;
                
                "-A"   )   echo Found -A  && [ -z "$slurmAcc" ] && slurmAcc="-A ${arr[2]}";;
                "--mem" ) [ -z "$mem" ] && echo Found --mem && mem="${arr[2]}";;
                --mem=* ) [ -z "$mem" ] && echo Found --mem= && mem="${arr[1]}" && mem="${mem/--mem=/}";;
                "--mem-per-cpu") [ -z "$mem1" ] && echo Found --mem-per-cpu && mem1="${arr[2]}";;
                --mem-per-cpu=*) [ -z "$mem1" ] && echo Found --mem-per-cpu= && mem1="${arr[1]}" && mem1="${mem1/--mem-per-cpu=/}";; 
                "-c"    ) [ -z "$core" ] && echo Found -c && core="${arr[2]}";;
                --cpus-per-task=* ) [ -z "$core" ] && echo Found --cpus-per-task= && core="${arr[1]}" && core="${core/--cpus-per-task=/}";;
                "-n"    ) [ -z "$task" ] && echo Found -n && task="${arr[2]}";;
                --ntasks=* ) [ -z "$task" ] && echo Found --ntasks= && task="${arr[1]}" && task="${task/--ntasks=/}";;
                "-N"    ) [ -z "$node" ] && echo Found -N && node="${arr[2]}";;
                --nodes=*   ) [ -z "$node" ] && echo Found --nodes= && node="${arr[1]}" && node="${node/--nodes=/}";;
                "-t"    ) [ -z "$time" ] && echo Found -t && time="${arr[2]}";;
                --time=* ) [ -z "$time" ] && echo Found --time= && time="${arr[1]}" && time="${time/--time=/}";;    
                "-o"    ) [ -z "$out" ] && echo Found -o && out="${arr[2]}";;
                --output=* ) [ -z "$out" ] && echo Found --output= && out="${arr[1]}" && out="${out/--output=/}";;
                "-e" ) [ -z "$err" ] && echo Found -e && err="${arr[2]}";;
                --error=* ) [ -z "$err" ] && echo Found --error= && err="${arr[1]}" && err="${err/--error=/}";;
                
                "-d"    ) [ -z "$dep" ] && echo Found -d && dep="${arr[2]}";;
                --dependency=* ) [ -z "$dep" ] && echo Found --dependency= && dep="${arr[1]}" && dep"${dep/--dependency=/}";;
            esac
        fi     
    done < $slurmScript 


    echo
    echo Parsing result from slurm script:  
    echo time: $time mem: $mem mem-per-cpu: $mem1 task: $task core: $core node: $node out: $out err: $err dep: $dep

    echo slurmScript: $slurmScript 
    echo additional sbatch parameter: $CMDWithoutSlurmCMD
    echo slurmScriptParas: $slurmScriptParas
fi

[ -z "$software" ] && [ ! -z "$SSBATCH_S" ] && software="$SSBATCH_S"
[ -z "$ref" ] && [ ! -z "$SSBATCH_R" ] && ref="$SSBATCH_R"
[ -z "$input" ] && [ ! -z "$SSBATCH_I" ] && inputs="$SSBATCH_I"
[ -z "$deps" ] && [ ! -z "$SSBATCH_D" ] && deps="$SSBATCH_D"

[ -z "$out" ] && out=slurm-%j.out  
[ -z "$err" ] && err=slurm-%j.err

# this is not pipeline
if [ -z "$logDir" ]; then  
    #[ -z "$software" ] && software=regularSbatch
    tm=`mktemp XXXXXXXX --dry-run`
    if [ -z "$software" ]; then
        if [ ! -z "$wrapCMD" ]; then
            arr=($wrapCMD)
            # need remove the parameters, to get unique name for job types
            if [[ "${arr[0]}" == sh || "${arr[0]}" == bash || "${arr[0]}" == python || ""${arr[0]}" == python3  || "${arr[0]}" == matlab || ""${arr[0]}" == Rscript ]]; then
            software="${arr[1]}" 
                else
            software="${arr[0]}"
            fi
            software=${software##*/}
        else
            software=${slurmScript##*/}
            #[ -z "$flag" ] && flag=$ref.${slurmScriptParas// /}.$tm
        fi
    fi
    job=${out/-\%j\.out/_$tm}.sh
    succFlag=${out/-\%j\.out/_$tm}.success
    #flag="$out $job $err"? 
    flag=${out/-\%j\.out/_$tm}
    
    #echo -e "#!/bin/bash\n\n" > $job 
    ##SBATCH -e $err\n#SBATCH -o $out\n" > $job
else 
    [ -d "$logDir" ] || { echo Directory not exist: $logDir; usage; }
    [ -z "$software" ] && { echo software is emtpty; usage; }
    flag=${flag//\//-}

    # todo: this is confusing, need work to make it clear
    flagDir=$logDir/log
    [ ! -d $flagDir ] && mkdir $flagDir 
    job=$flagDir/$flag.sh
    #echo -e "#!/bin/bash\n\n" > $job
    #submitFlag=$flagDir/$flag.submitted
    succFlag=$flagDir/$flag.success
    failFlag=$flagDir/$flag.failed
    #startFlag=$flagDir/$flag.start
    killFlag=$flagDir/$flag.user.killed
    outFlag=$flagDir/$flag.out
    errFlag=$flagDir/$flag.err
    deps=${deps#.}        
fi    


[ -z "$ref" ] && ref=none
[ -z "$inputs" ] && inputs=none
[ -z "$deps" ] && deps=null


if [ -z "$mem" ]; then
    if [ -z "$mem1" ]; then
        mem=$defaultMem
    else
        [[ "$mem1" == *G ]] && mem=$(( ${mem1%G} * $core ))G || mem=$(( ${mem1%M} * $core ))M
    fi
fi

if [[ $deps == null ]]; then
    deps=""
    resAjust="#Depend on no job\n"
    
elif [[ $deps == ${deps/\./} ]]; then
    resAjust="#Depend on single job\n"
    deps="--dependency=afterok:${deps/\./}"
else
    resAjust="#Depend on multiple jobs\n"
    tmp=""
    for t in ${deps//\./ }; do
        #echo working on $t >&2  test
        tmp="$tmp:$t"
    done
    [ ! -z "$tmp" ] && deps="--dependency=afterok$tmp"
fi

resAjust="#Original mem $mem, Original time: $time\n"

# check job done before or not
if [[ ! -z "$logDir" && "$testRun" == "run" ]]; then 
    if [ -f $succFlag ]; then
        stepID=${flag%%.*}
        if ([ -f $flagDir/skipAllSuccessJobs.txt ] || [ -f $flagDir/skipAllSuccessJobs$stepID.txt ]) && [ -z "$deps" ]; then 
            echo skipThisJob
            exit    
        elif [ ! -f $flagDir/reRunAllSuccessJobs.txt ] && [ ! -f $flagDir/reRunAllSuccessJobs$stepID.txt ] && [ -z "$deps" ]; then
            stepName=${flag#*.}; stepName=${stepName#*.}; stepName=${stepName%%.*}
            echo $flag was done before, do you want to re-run it? >&2
            echo -e "y:        To re-run this job, press y, then enter key." >&2
            echo -e "ystep:    To re-run all jobs for step $stepID: $stepName, type ystep, then press enter key." >&2
            echo -e "yall:     To re-run all jobs, type yall, then press enter key." >&2
            echo -e "enter:    To not re-run this job, directly press enter key." >&2
            echo -e "nstep:    To not re-run all successful jobs for step $stepID: $stepName, type nstep, then press enter key." >&2
            echo -e "nall:     To not re-run all successful jobs, type nall, then press enter key." >&2
            read -p "" x </dev/tty

            if [[ "$x" == "y" ]]; then
                echo "Will re-run the down stream steps even if they are done before (because they have deps - see code in row 70)." >&2 
            elif [[ "$x" == "ystep" ]]; then 
                touch $flagDir/reRunAllSuccessJobs$stepID.txt
            elif [[ "$x" == "nstep" ]]; then
                touch $flagDir/skipAllSuccessJobs$stepID.txt
                echo skipThisJob
                exit
            elif [[ "$x" == "yall" ]]; then 
                touch $flagDir/reRunAllSuccessJobs.txt
            elif [[ "$x" == "nall" ]]; then
                touch $flagDir/skipAllSuccessJobs.txt
                echo skipThisJob
                exit    
            else
                echo skipThisJob
                exit
            fi  
        fi
        #echo
        #rm $succFlag
        #ls -l $flagDir/ 1>&2 
    elif [ -f log/keepRunningJobs.txt ]; then 
     
        #set -x    
        #cat log/allJobs.txt >&2

        #echo $flag >&2
        # check the third column for the job name, then find the the job id in column 1
        out=`cat log/allJobs.txt | awk '{if ($3 ~ /'"$flag/"') print $1, $2;}' | tail -n 1`
        id=${out%% *}; de=${out##* }    
    
        if [ ! -z "$id" ]; then   
            if grep ^$id log/keepRunningJobs.txt 1>/dev/null; then 
                # the dependency is not changed from the last submit 
                if [[ "$depsO" == "$de" ]]; then 
                    echo thisJobStillRunning $id here&& exit
                else    
                    scancel $id 
                fi
                #echo $deps

                # comment out because deps can include the upstream jobs
                # check if the upseam jobs still running
                # dep=`grep ^$id log/keepRunningJobs.txt | cut -d' ' -f2`
                
                # if [[ "$dep" != "null" ]]; then 
                #     for t in ${dep//\./ }; do
                #         #still runnig, add to the dependency
                #         grep ^$t log/keepRunningJobs.txt 2>/dev/null && deps=$deps:$t && depsO=$depsO.$t
                #     done
                
                # fi  
            fi 
        fi
        set +x 
    fi    
    #ls $flagDir/$flag.* 1>&2
    rm $flagDir/$flag.* 2>/dev/null || : # in case user has set -e and file not exist,  we will not exit
fi

[ -z "$time" ] && time=$defaultTime

# original mem and time 
memO=$mem; timeO=$time
inputSize=0

echo 
echo Check if there input file list and this job does not depend on other jobs


# do not have input file list    #todo: we can try to figure out the input from the software parameters here
if [[ "$inputs" == "none" ]]; then
    echo No inputs
    resAjust="$resAjust#This job does not have input.\n"
    ref=${ref//\//-}
    
    rows=`( wc -l $jobRecordDir/stats/$software.$ref.mem.stat.noInput 2>/dev/null || echo 0 ) | awk '{print $1}'`
    #echo rows  $rows >&2
    # empty or more than 60 minutes but less than 4 records
    if test `find $jobRecordDir/stats/$software.$ref.mem.stat.noInput -mmin +60 2>/dev/null` && [ $rows -lt 3 ] || [ $rows -eq 0 ]; then  
        mkdir -p $jobRecordDir/stats/
        #cat /home/*/smartSlurm/stats/myJobRecord.txt > $jobRecordDir/stats/jobRecord.txt 
        #test `find $jobRecordDir/jobRecord.txt -mmin +20` && echo jobRecord.txt synced within 21 hour. No need to re-sync || cat $HOME/smartSlurm/myJobRecord.txt > $jobRecordDir/jobRecord.txt  

        # todo: could use single file here
        grep COMPLETED $jobRecordDir/jobRecord.txt 2>/dev/null | awk -F, -v a=$software -v b=$ref '{ if($12 == a && $13 == b) {print $7 }}' > $jobRecordDir/stats/$software.$ref.mem.stat.noInput
     
        grep COMPLETED $jobRecordDir/jobRecord.txt 2>/dev/null | awk -F, -v a=$software -v b=$ref '{ if($12 == a && $13 == b) {print $8 }}' > $jobRecordDir/stats/$software.$ref.time.stat.noInput
        
        if [ -s $jobRecordDir/stats/$software.$ref.mem.stat.noInput ] && [ -s $jobRecordDir/stats/$software.$ref.time.stat.noInput ]; then 
            
            OUT="$(mktemp -d)"
            paste $jobRecordDir/stats/$software.$ref.time.stat.noInput $jobRecordDir/stats/$software.$ref.mem.stat.noInput | column -s $'\t' -t | sed '$ d' > $jobRecordDir/stats/$software.$ref.timeMem.noInput.txt

            cp $jobRecordDir/stats/$software.$ref.timeMem.noInput.txt $OUT/timeMem.txt
            cd $OUT
            # make plot and calculate statistics
            gnuplot -e 'set term pdf; set output "timeMem.pdf"; set title "Time vs. Memory Usage" font "Helvetica Bold,18"; set xlabel "Time(Min)"; set ylabel "Memory(M)"; f(x)=a*x+b; fit f(x) "timeMem.txt" u 1:2 via a, b; t(a,b)=sprintf("f(x) = %.2fx + %.2f", a, b); plot "timeMem.txt" u 1:2,f(x) t t(a,b); print "Finala=", a; print "Finalb=",b; stats "timeMem.txt" u 1 ' 2>&1 | grep 'Final\| M' | awk 'NF<4{print $1, $2}' |sed 's/:/=/' | sed 's/ //g' > $software.$ref.timeMem.stat.noInput.txt

            cd - 
            convert $OUT/timeMem.pdf -background White -flatten $jobRecordDir/stats/$software.$ref.stat.noInput.pdf 2>/dev/null
            pdftoppm $jobRecordDir/stats/$software.$ref.stat.noInput.pdf  -png > $jobRecordDir/stats/$software.$ref.stat.noInput.png 2>/dev/null
            
            rows=`{ wc -l $jobRecordDir/stats/$software.$ref.mem.stat.noInput 2>/dev/null || echo 0; } | cut -f 1 -d " "` 
        
            rm -r $OUT 2>/dev/null 
        fi
    fi

    # at least 3 records
    if [ $rows -gt 3 ]; then
        cutoffRow=$(( ($row - 1)  / 10  + 1)) # top 10
        
        mem=`cat $jobRecordDir/stats/$software.$ref.mem.stat.noInput | sort -nr | tr '\n' ' ' | cut -f $cutoffRow -d " "`
        mem=$((${mem/\.*/} + extraMem))M
#       mem=${txt[$cutoffRow]}; mem=$((${mem/\.*/} + extraMem))M

        time=`cat $jobRecordDir/stats/$software.$ref.time.stat.noInput | sort -nr | tr '\n' ' ' | cut -f $cutoffRow -d " "`
        time=$((${time/\.*/} + extraMin))
        
#         time=`head -n $((cutoffRow+1)) $jobRecordDir/stats/$software.$ref.time.stat.noInput | tail -n 1`        
#         time=$((time + extraMin))
        resAjust="$resAjust#Got estimation based on software.reference: $software.$ref.\n" 
        resAjust="$resAjust#Give ${extraMem}M extra memory and $extraMin more minutes. \n#So use this to submit the job: $mem  ${time}m"
        
    else 
        resAjust="$resAjust#There are less than 3 job records. Use default mem and time."
    fi


# not depends on other job, and there is input file list
elif [ -z "$deps" ]; then
    echo Does not depend on other jobs and have inputs.
    inputSize=`{ du --apparent-size -c -L ${inputs//,/ } 2>/dev/null || echo notExist; } | tail -n 1 | cut -f 1`

    if [[ "$inputSize" == "notExist" ]]; then 
        resAjust="$resAjust#Some or all input files not exist: $inputs\n"
        echo Error! missingInputFile: ${inputs//,/ }
        exit 
    else 
        #inputSize=$(($inputSize/1024)); # convert to M      
        resAjust="$resAjust#InputSize: $inputSize\n"
        
        #rm ~/.rcbio/$software.$ref.mem.stat # for testing 
    
        if [ -f $jobRecordDir/stats/$software.${ref//\//-}.mem.stat ]; then    
            output=`estimateMemTime.sh $software ${ref//\//-} $inputSize`
            resAjust="$resAjust#Output from estimateMemTime.sh: $output \n"
            if [[ "$output" == "outOfRange" ]]; then 
                resAjust="$resAjust#Input size is too big for the curve to estimate! Use default mem and runtime to submit job.\n"
                # not deleting mem.stat, so other jobs will not re-build it within 60 minutes
            elif [ ! -z "$output" ]; then
                mem=$((${output% *}+extraMem))M; time=$((${output#* }+extraMin));     
                resAjust="$resAjust#Give ${extraMem}M extra memory and $extraMin more minutes. \n#So use this to submit the job: $mem  ${time}m"
            fi 
        
        fi
        
        if [[ "$output" == "outOfRange" ]] && test `find $jobRecordDir/stats/$software.${ref//\//-}.mem.stat -mmin +60` || [ ! -f $jobRecordDir/stats/$software.${ref//\//-}.mem.stat ]; then  
            resAjust="$resAjust#Do not have a formula, or it is old and out of range. Let us build one...\n"   

            #[ test `find $jobRecordDir/jobRecord.txt -mmin -20` ] && echo jobRecord.txt synced within 20 hour. No need to re-sync || cat $HOME/smartSlurm/myJobRecord.txt > $jobRecordDir/jobRecord.txt  
            
            #jobStatistics.sh $software ${ref//\//-} 4 1>&2 
            
            OUT="$(mktemp -d)"

            #filter by software and reference
            # todo: maybe able to replace / in ref at begaining of the script?
            ref=${ref//\//-}
            grep COMPLETED $jobRecordDir/jobRecord.txt 2>/dev/null | awk -F"," -v a=$software -v b=$ref '{ if($12 == a && $13 == b) {print $2, $7 }}' | sort -r  -k1,1 -k2,2 | sort -u -k1,1 > $OUT/mem.txt
            grep COMPLETED $jobRecordDir/jobRecord.txt 2>/dev/null | awk -F"," -v a=$software -v b=$ref '{ if($12 == a && $13 == b) {print $2, $8 }}' | sort -r  -k1,1 -k2,2 | sort -u -k1,1 > $OUT/time.txt

            echo "Got mem data from jobRecord.txt (content of mem.txt):"
            cat $OUT/mem.txt 

            echo "Got time data from jobRecord.txt (content of time.txt):"
            cat $OUT/time.txt 

            if [[ $(wc -l <$OUT/mem.txt) -lt 3 ]]; then
                echo There are less than 3 records. No way to fit a curve. Exiting...
                resAjust="$resAjust#There are less than 3 records. No way to fit a curve.\n"
                 
            else

                cd $OUT

                # make plot and calculate statistics
                gnuplot -e 'set term pdf; set output "mem.pdf"; set title "Input Size vs. Memory Usage" font "Helvetica Bold,18"; set xlabel "Input Size(K)"; set ylabel "Memory Usage(M)"; f(x)=a*x+b; fit f(x) "mem.txt" u 1:2 via a, b; t(a,b)=sprintf("f(x) = %.2fx + %.2f", a, b); plot "mem.txt" u 1:2,f(x) t t(a,b); print "Finala=", a; print "Finalb=",b; stats "mem.txt" u 1 ' 2>&1 | grep 'Final\| M' | awk 'NF<4{print $1, $2}' |sed 's/:/=/' | sed 's/ //g' > mem.stat.txt

                # make plot and calculate statistics
                gnuplot -e 'set term pdf; set output "time.pdf"; set title "Input Size vs. Time Usage" font "Helvetica Bold,18"; set xlabel "Input Size(K)"; set ylabel "Time(Min)"; f(x)=a*x+b; fit f(x) "time.txt" u 1:2 via a, b; t(a,b)=sprintf("f(x) = %.2fx + %.2f", a, b); plot "time.txt" u 1:2,f(x) t t(a,b); print "Finala=", a; print "Finalb=",b; stats "time.txt" u 1 ' 2>&1 | grep 'Final\| M' | awk 'NF<4{print $1, $2}' |sed 's/:/=/' | sed 's/ //g' > time.stat.txt
                
                mv $OUT/mem.stat.txt $jobRecordDir/stats/$software.$ref.mem.stat 
                mv $OUT/time.stat.txt $jobRecordDir/stats/$software.$ref.time.stat  
                echo There are more than $ref jobs already run for this software, statics is ready for current job: 
                echo Memeory statisics:
                echo "inputsize mem(M)"
                cat $jobRecordDir/stats/$software.$ref.mem.stat
                echo
                echo Time statistics:
                echo "inputsize time(minute)"
                cat $jobRecordDir/stats/$software.$ref.time.stat
 
                mv $OUT/mem.txt $jobRecordDir/stats/$software.$ref.mem.txt
                mv $OUT/time.txt $jobRecordDir/stats/$software.$ref.time.txt

                convert $OUT/mem.pdf -background White -flatten $jobRecordDir/stats/$software.$ref.mem.pdf
                convert $OUT/time.pdf -background White -flatten $jobRecordDir/stats/$software.$ref.time.pdf
                pdftoppm $jobRecordDir/stats/$software.$ref.mem.pdf  -png > $jobRecordDir/stats/$software.$ref.mem.png
                pdftoppm $jobRecordDir/stats/$software.$ref.time.pdf  -png > $jobRecordDir/stats/$software.$ref.time.png

                echo
                echo You can see the plot using commands:
                echo display $jobRecordDir/stats/$software.$ref.mem.pdf
                echo display $jobRecordDir/stats/$software.$ref.time.pdf
                
                cd -

                

                echo got files in $jobRecordDir/stats:  
                #ls -lrt $jobRecordDir/stats
                
                if [ -f $jobRecordDir/stats/$software.${ref//\//-}.mem.stat ]; then    
                    output=`estimateMemTime.sh $software ${ref//\//-} $inputSize`
                    resAjust="$resAjust#Output from estimateMemTime.sh: $output \n"
                    if [[ "$output" == "outOfRange" ]]; then 
                        resAjust="$resAjust#Input size is too big for the curve to estimate! Use default mem and runtime to submit job.\n"
                        # not deleting mem.stat, so other jobs will not re-build it within 60 minutes
                    elif [ ! -z "$output" ]; then
                        mem=$((${output% *}+extraMem))M; time=$((${output#* }+extraMin));     
                        resAjust="$resAjust#Give ${extraMem}M extra memory and $extraMin more minutes. \n#So use this to submit the job: $mem  ${time}m"
                    fi
                    #echo got estimation $output  
                fi        
            fi
            rm -r $OUT 2>/dev/null
        fi
       
    fi
else
    echo Has input, but depends on other jobs
    resAjust="$resAjust#Use default mem and time. Has input, but this job depends on other job."
fi

#echo

[ -z "$time" ] && { echo did not find time limit >&2; exit 1; }
 
[ -z "$mem" ] && { echo did not find mem limit >&2; exit 1; } 

[ -z "$core" ] && { [ ! -z "$task" ] && core="$task" || core=1; } 

[[ "$time" == *-* ]] && { day=${time%-*}; tem=${time#*-}; hour=${tem%%:*}; min=${tem#*:}; min=${min%%:*}; sec=${tem#$hour:$min}; sec=${sec#:}; } || { [[ "$time" =~ ^[0-9]+$ ]] && min=$time || { sec=${time##*:}; min=${time%:*}; min=${min##*:}; hour=${time%$min:$sec}; hour=${hour%:}; day=0;} }

[ -z "$day" ] && day=0; [ -z "$hour" ] && hour=0; [ -z "$min" ] && min=0;[ -z "$sec" ] && sec=0

# resAjust="$resAjust#day $day,  hour $hour,  min $min,  sec $sec"

# how many hours for sbatch command
hours=$(($day * 24 + $hour + ($min + 59 + ($sec + 59) / 60 ) / 60))

#echo looking partition for hour: $hours 

adjustPartition $hours $partition

time=$day-$hour:$min:$sec

# 10 minutes less than the time in sbatch command
#seconds=$(($day * 24 * 60 * 60 + $hour * 60 * 60  + $min * 60 + $sec - 600))

#[ $seconds -le 60 ] && time=11:0 && seconds=60

#echo srun seconds: $seconds

#timeN=`eval "echo $(date -ud "@$seconds" +'$((%s/3600/24))-%H:%M:%S')"`

#echo New time for srun: $timeN

#echo 

# mem for srun is 10M less than sbatch command
#[[ "$mem" == *G ]] && memN=$(( 1024 * ${mem%G} -10 ))M || memN=$(( ${mem%M} -10 ))M

#[ ${memN%M} -le 1 ] && { echo Error: --mem for sbatch command should bigger than 11M; usage; }
#[ ${memN%M} -le 1 ] && mem=20M && memN=10M

#echo Mew mem for srun: $memN

#[ -z "$out" ] && out="slurm-\$SLURM_JOBID.out"
#[ -z "$err" ] && err="slurm-\$SLURM_JOBID.err"

echo 
echo Building new sbatch command ... >&2
#echo "#!/bin/bash" > $job 

echo -e "#!/bin/bash\n$resAjust\n\ntrap \"{ cleanUp.sh \\\"$logDir\\\" \"$software\" \"${ref//\//-}\" \\\"$flag\\\" \"$inputSize\" \"$core\" \"$memO\" \"$timeO\" \"$mem\" \"$(($day * 24 * 60 + $hour * 60 + $min + 1))\" \"$partition\"  \\\"${slurmAcc#*-A }\\\" \"$inputs\"; }\" EXIT\ngetMaxMem.sh &\n" > $job

[[ "$mem" == *G ]] && totalM=$(( 1024 * ${mem%G})) || totalM=${mem%M}

[ $totalM -lt 20 ] && totalM=20

#echo "set -x" >> $job
echo "if [ ! -f log/$flag.adjust ]; then" >> $job
echo "   totalM=$totalM" >> $job
echo "else " >> $job
echo "   totalM=\`cat log/$flag.adjust\`" >> $job
## todo: this might work if cluster is bussy, may need sleep more or get the data from a text file
#echo "   sleep 10; sacct=\`sacct --format=JobID,Submit,Start,End,MaxRSS,State,NodeList%30,Partition,ReqTRES%30,TotalCPU,Elapsed%14,Timelimit%14 --units=M -j \$SLURM_JOBID\` " #>> $job
#echo "   totalM=\${sacct#*,mem=}; totalM=\${totalM%%M,n*}" >> $job
echo "fi" >> $job 
echo "srunM=\$((\$totalM - 15))M" >> $job

if [ -z "$slurmScript" ]; then 
    #echo "touch $startFlag" >> $job
    wrapCMD=`echo $wrapCMD | xargs echo -n`; wrapCMD=${wrapCMD%;} # remove ending space and ; from command
    echo "srun --mem \$srunM -n 1 $slurmAcc bash -e -c \"{ $wrapCMD; } && touch $succFlag\"" >> $job 
else 
    grep "^#SBATCH" $slurmScript >> $job || : >> $job
    #echo "touch $startFlag" >> $job
    echo "srun -mem \$srunM -n 1 $slurmAcc bash -e -c \"{ sh $slurmScript $slurmScriptParas; } && touch $succFlag\"" >> $job 
fi
#echo "kill -9 \$mypid" >> $job
#echo "sleep 15 # wait slurm get the job status into its database" >> $job 

#echo "echo Job done. Summary:" >> $job 

# echo "sacct --format=JobID,Submit,Start,End,MaxRSS,State,NodeList%30,Partition,ReqTRES%30,TotalCPU,Elapsed%14,Timelimit%14 --units=M -j \$SLURM_JOBID" >> $job 
# #echo SLURM_JOBID=\$SLURM_JOBID >> $job

# echo "emailAndRecord.sh \"$software\" \"${ref//\//-}\" \"$flag\" \"$inputSize\" \"$core\" \"$memO\" \"$timeO\" \"$mem\" \"$time\"" >> $job #  >/dev/null" >> $job 

# echo "adjustDownStreamJobs.sh $flagDir" >> $job 

# echo "[ -f $succFlag ] ||  { touch $failFlag; exit 1; }" >> $job

#[ -z "$dir" ] && dir="./" || mkdir -p $dir

## todo: need fix this when path not starting with /
[ -z "$out" ] || ( [[ "$out" == /* ]] && mkdir -p $(dirname $out) || mkdir -p $dir/$(dirname $out) )
[ -z "$err" ] || ( [[ "$err" == /* ]] && mkdir -p $(dirname $err) || mkdir -p $dir/$(dirname $err) )

# [ -f $outFlag ] && [ ! -z "$out" ] && [[ ! $outFlag == "$out" ]] && echo ln -s $outFlag $out >> $job
# [ -f $errFlag ] && [ ! -z "$err" ] && [[ ! $errFlag == "$err" ]] && echo ln -s $errFlag $err >> $job

# testing
#mem=2000M

if [ -z "$logDir" ]; then
    cmd="/usr/bin/sbatch --mail-type=FAIL --requeue --parsable -p $partition --mem ${totalM}M -t $time --open-mode=append $slurmAcc"
else
    cmd="/usr/bin/sbatch --mail-type=FAIL --requeue --parsable -p $partition --mem ${totalM}M -t $time --open-mode=append -o $outFlag -e $outFlag -J $flag $deps $slurmAcc"
    #rm $startFile $failFile $flag.failed $flag.killed # 2>/dev/null  || : 
fi
if [ -z "$slurmScript" ]; then 
    cmd="$cmd $CMDWithoutWrap $job" 
else 
    cmd="$cmd $CMDWithoutSlurmCMD $job $slurmScriptParas" 
fi



echo -e "\n#Command used to submit the job:" >> $job
echo "#$cmd" >> $job 

#echo $resAjust

echo New sbatch command to submit job: 
echo $cmd 
if [[ "$testRun" == "run" ]]; then
    echo Start submtting job...
    #output=`$cmd`
    #echo $output
    jobID=`$cmd`
    
    echo Output is: $jobID
    #touch $submitFlag  
else 
    jobID=$(date +"%4N")
    #echo This is a testing, not really running a job...
    echo "This is testing, so no job is submitted. In real run it should submit job such as: Submitted batch job $jobID"
    #jobID=
fi    

# add this to the job script
echo -e "\n#Sbatch command output:\n#Submitted batch job $jobID" >> $job 

# print out on screen
#echo -e "Sbatch command output:\nSubmitted batch job $jobID"

#dep=${dep#afterok}; dep=${dep//:/.}; [ -z "$dep" ] && dep=null 

# for check dependency, rerun, kill downstream jobs, estimate memmory and run time
#[[ "$jobID" =~ ^[0-9]+$ ]]  &&  echo $jobID $dep $flag $software $ref $inputs >> $flagDir/allJobs.txt

if [ -z "$logDir" ]; then
    out=${out/\%j/$jobID}; 
    ln -s $job ${out/.out/}.sh
else
    printf "%-10s  %-20s  %-10s %-10s %-10s %-10s\n" $jobID $depsO $flag $software $ref $inputs>> $flagDir/allJobs.txt;
fi

echo New slurmScirpt is ready. The content is: >&2
cat $job >&2

echo Submitted batch job $jobID


